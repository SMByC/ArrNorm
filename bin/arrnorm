#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import argparse
import multiprocessing
import queue
from subprocess import call

# add project dir to pythonpath
project_dir = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
if project_dir not in sys.path:
    sys.path.append(project_dir)

from arrnorm import iMad, radcal, register

header = '''
==============================================================

ArrNorm - Automatic Relative Radiometric Normalization

Some code base on: Dr. Mort Canty
                   https://github.com/mortcanty/CRCDocker

Copyright (c) SMByC-IDEAM
Author: Xavier C. Llano <xavier.corredor.llano@gmail.com>
Sistema de Monitoreo de Bosques y Carbono - SMByC
IDEAM, Colombia

==============================================================
'''
print(header)

# ==============================================================================
# PARSER AND CHECK ARGUMENTS

# Create parser arguments
arguments = argparse.ArgumentParser(
    prog="arrnorm",
    description="Automatic relative radiometric normalization",
    epilog="Xavier Corredor Llano <xcorredorl@ideam.gov.co>\n"
           "Sistema de Monitoreo de Bosques y Carbono - SMBYC\n"
           "IDEAM, Colombia",
    formatter_class=argparse.RawTextHelpFormatter)

arguments.add_argument('-ref', type=str, default="/home/smbyc/data/Cristhian/Landsat/AV2575_C2_2000_2021_v1.tif",
                       help='reference image for iMad normalize', required=False)

arguments.add_argument('-i', type=int, default=10,
                       help='number of iterations', required=False)

arguments.add_argument('-t', type=float, default=0.95,
                       help='no-change probability threshold', required=False)

arguments.add_argument('-m', action='store_true', default=False,
                       help='create and apply nodata mask', required=False)

# arguments.add_argument('-p', type=int, default=multiprocessing.cpu_count() - 1,
arguments.add_argument('-p', type=int, default=1,
                       help='number of process/threads', required=False)

arguments.add_argument('-reg', action='store_true', default=False,
                       help='registration image-image in frequency domain', required=False)

arguments.add_argument('-warpband', type=int, default=2,
                       help='number of target band for make registration, requires "-reg"', required=False)

arguments.add_argument('-chunksize', type=int, default=None,
                       help='chunk size for make registration by chunks, requires "-reg"', required=False)

arguments.add_argument('-onlyreg', action='store_true', default=False,
                       help='only makes registration process and not iMad normalize, requires "-reg"', required=False)

arguments.add_argument('images', type=str, nargs='+',
                       help='images to apply the iMad normalization')

arg = arguments.parse_args()


# ==============================================================================
# PROCESS IMAGES


class Normalization:
    def __init__(self, count, img_ref, img_target):
        self.count = count
        self.img_ref = img_ref
        self.img_target = img_target
        self.ref_text = "Image ({0}/{1})".format(self.count + 1, len(arg.images))
        self.max_iters = arg.i

    def run(self):

        print("\nPROCESSING IMAGE: {target} ({count})".format(
            target=os.path.basename(self.img_target),
            count=str(self.count + 1) + '/' + str(len(arg.images))
        ))

        self.clipper()

        if arg.reg:
            self.register()
            #self.no_negative_value(self.img_target_reg)

            if arg.onlyreg:
                print('\nDONE: {ref_text} PROCESSED\n'
                      '      register successfully for:  {img_orig}\n'.format(
                        ref_text=self.ref_text,
                        img_orig=os.path.basename(self.img_target)))
                return

        self.imad()
        self.radcal()
        self.no_negative_value(self.img_norm)

        if arg.m:
            self.make_mask()
            self.apply_mask()

        self.clean()

        print('\nDONE: {ref_text} PROCESSED\n'
              '      ArrNorm successfully for:  {img_orig}\n'
              '      image normalized saved in: {img_norm}\n'.format(
                ref_text=self.ref_text,
                img_orig=os.path.basename(self.img_target),
                img_norm=os.path.basename(self.img_norm)))

    def clipper(self):
        """Clip the reference image with the target image"""
        from osgeo import gdal
        from osgeo.gdalconst import GA_ReadOnly

        print("\n======================================\n"
              "Clipping the ref image with target:", self.ref_text, os.path.basename(self.img_ref))

        data = gdal.Open(self.img_target, GA_ReadOnly)
        geoTransform = data.GetGeoTransform()
        minx = geoTransform[0]
        maxy = geoTransform[3]
        maxx = minx + geoTransform[1] * data.RasterXSize
        miny = maxy + geoTransform[5] * data.RasterYSize
        print("Extent:", minx, maxy, maxx, miny)
        data = None
        filename, ext = os.path.splitext(os.path.basename(self.img_ref))
        self.img_ref_clip = os.path.join(os.path.dirname(os.path.abspath(self.img_target)),
                                         filename + "_" + os.path.splitext(os.path.basename(self.img_target))[0]
                                         + "_clip" + ext)

        return_code = call(
            'gdal_translate -projwin ' + ' '.join([str(x) for x in [minx, maxy, maxx, miny]]) +
            ' -of GTiff "' + self.img_ref + '" "' + self.img_ref_clip + '"',
            shell=True)
        if return_code == 0:  # successfully
            print('Clipped ref image successfully: ' + os.path.basename(self.img_ref_clip))
        else:
            print('\nError clipping reference image: ' + str(return_code))
            sys.exit(1)

    def register(self):
        # ======================================
        # registration image-image in frequency domain

        print("\n======================================\n"
              "Registration image-image in frequency domain:", self.ref_text, os.path.basename(self.img_target))
        self.img_target_reg = register.main(self.img_ref_clip, self.img_target, arg.warpband, arg.chunksize)

    def imad(self):
        # ======================================
        # iMad process

        if arg.reg:
            img_target = self.img_target_reg
        else:
            img_target = self.img_target

        print("\n======================================\n"
              "iMad process for:", self.ref_text, os.path.basename(self.img_target))
        self.img_imad = iMad.main(self.img_ref_clip, img_target,
                                  ref_text=self.ref_text, max_iters=self.max_iters)

    def radcal(self):
        # ======================================
        # Radcal process

        print("\n======================================\n"
              "Radcal process for:", self.ref_text, os.path.basename(self.img_target),
              " with iMad image: ", os.path.basename(self.img_imad))
        self.img_norm = radcal.main(self.img_imad, ncpThresh=arg.t)

    def no_negative_value(self, image):
        # ======================================
        # Convert negative values to NoData to image normalized

        print('\n======================================\n'
              'Converting negative values for:', self.ref_text, os.path.basename(image))
        return_code = call(
            'gdal_calc.py -A "' + image + '" --outfile="' + image + '" --type=UInt16 --calc="A*(A>=0)" --NoDataValue=0'
                                                                    ' --allBands=A  --overwrite --quiet --co BIGTIFF=YES',
            shell=True)
        if return_code == 0:  # successfully
            print('Negative values converted successfully: ' + os.path.basename(image))
        else:
            print('\nError converting values: ' + str(return_code))
            sys.exit(1)

    def make_mask(self):
        # ======================================
        # Make mask

        if arg.reg:
            img_to_process = self.img_target_reg
        else:
            img_to_process = self.img_target

        print('\n======================================\n'
              'Making mask for:', self.ref_text, os.path.basename(img_to_process))

        filename, ext = os.path.splitext(os.path.basename(img_to_process))
        self.mask_file = os.path.join(os.path.dirname(os.path.abspath(img_to_process)), filename + "_mask" + ext)
        return_code = call(
            'gdal_calc.py -A "' + img_to_process + '" --type=Byte --co COMPRESS=PACKBITS  --co BIGTIFF=YES --outfile="'
            + self.mask_file + '" --calc="1*(A>0)" --NoDataValue=0 --quiet --overwrite',
            shell=True)
        if return_code == 0:  # successfully
            print('Mask created successfully: ' + os.path.basename(self.mask_file))
        else:
            print('\nError creating mask: ' + str(return_code))
            sys.exit(1)

    def apply_mask(self):
        # ======================================
        # Apply mask to image normalized

        print('\n======================================\n'
              'Applying mask for:', self.ref_text, os.path.basename(self.img_norm))
        return_code = call(
            'gdal_calc.py -A "' + self.img_norm + '" -B "' + self.mask_file
            + '" --type=UInt16 --co COMPRESS=LZW --co PREDICTOR=2 --co BIGTIFF=YES --outfile="'
            + self.img_norm + '" --calc="A*(B==1)" --NoDataValue=0  --allBands=A  --overwrite --quiet',
            shell=True)
        if return_code == 0:  # successfully
            print('Mask applied successfully: ' + os.path.basename(self.mask_file))
        else:
            print('\nError applied mask: ' + str(return_code))
            sys.exit(1)

    def clean(self):
        # delete the MAD file
        os.remove(self.img_imad)
        # delete the clip reference image
        os.remove(self.img_ref_clip)



# ======================================
# Multiprocessing

multiprocessing.freeze_support()
# create the instance
q = queue.Queue()
# number of threads
number_of_processes = arg.p


def process(norm_class, args):
    norm_instance = norm_class(*args)
    norm_instance.run()


def meta_process(args):
    process(*args)


print('Reference image: ', os.path.basename(arg.ref))
print('Creating {num_proc} multiprocesses'.format(num_proc=number_of_processes))

with multiprocessing.Pool(number_of_processes) as pool:

    TASKS = [(Normalization, (img_count, arg.ref, img_target)) for img_count, img_target in enumerate(arg.images)]

    imap_it = pool.imap(meta_process, TASKS)

    [proc for proc in imap_it]


print('\nFINISH: successfully process for {num_img} images\n'.format(num_img=len(arg.images)))
